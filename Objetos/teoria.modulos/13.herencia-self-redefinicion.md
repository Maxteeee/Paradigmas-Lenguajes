## Enunciado (seguimos con pepita)

Un ornitólogo, luego de estudiar el comportamiento de las golondrinas tijerita como pepita, se dio cuenta de que existen otros 2 tipos de aves que le interesan:
- el petrel
- y la torcaza

Todas saben volar y comer igual que pepita, pero
- al ornitólogo le interesa saber la cantidad de kilómetros que vuela un petrel
- la torcaza es medio atolondrada, antes de comer se pone tan contenta que vuela en círculos 1 kilómetro

## Intro a SUPERCLASE

Sabemos que una clase es el concepto que permite agrupar el comportamiento (y la estructura) de cada una de las instancias

Pero como el petrel “vuela distinto” (para nuestro sistema) y la torcaza “come distinto”, esto nos lleva a modelar tres clases diferentes: GolondrinaTijerita, Petrel y Torcaza.

Ahora bien, no queremos repetir el mismo código para las 3 clases al comer y al volar.

Afortunadamente, podemos relacionar una clase con otra: GolondrinaTijerita, Petrel y Torcaza pueden tener a Ave como clase madre o superclase. Las superclases tienden a representar un concepto más general, mientras que las subclases se enfocan a especializaciones o casos particulares.

# Herencia 

Recordemos cómo es el comportamiento de una golondrina tijerita (osea pepita)
- cuando vuela, consume un joule para cada kilómetro que vuela, más 10 joules de "costo fijo" en cada vuelo
- cuando come, adquiere 4 joules por cada gramo que come

Este comportamiento puede ahora ser la definición por defecto de un Ave. Creamos la clase Ave en Wollok:

```wollok
/**
* Definición por defecto de un Ave
*/
class Ave {
	var energia = 50
	
	method volar(kilometros) {
		energia = energia - (kilometros + 10)
	}
	
	method comer(gramos) {
		energia = energia + gramos * 4
	}
}
```

Como la golondrina se comporta "igual que un ave" tiene que *HEREDAR* sus caracteristicas, esto se define asi en *CODIGO*


```wollok
class GolondrinaTijerita inherits Ave { }
```

Ahora sabe comer y volar como lo hace un ave pero ademas podemos agregarle comportamientos como

```wollok
class GolondrinaTijerita inherits Ave {
method hacerAlgo(conCosa) { ... }
}
```

# Method lookup

Si instamos una golondrina tijeria, pepita en nuestro caso

>>> const pepita = new GolondrinaTijerita()

podemos enviarle mensajes como volar o comer a pepita, pero como es que pepita los entiende? bueno hay que revisar la definicion de method lookup

Hasta ahora al enviar un mensaje a un objeto
- si se trata de un objeto autodefinido o “well-known object”, se ejecuta el método que está en dicho objeto
- si es instancia de una clase, comenzamos buscando el método en la clase a la que pertenece dicha instancia. En el ejemplo de pepita, buscamos el método “volar(kilometros)” en la clase GolondrinaTijerita.

Ahora  extendemos lo que sucede si no encontramos la definición en la clase del objeto receptor:

- la búsqueda continúa en la superclase, en este caso Ave. Aquí tenemos definido un método volar con un parámetro y se evalúa para los valores que tiene pepita.
- En el caso de no existir en la superclase, se sigue buscando en la clase superior, hasta llegar a Object (la clase madre de todas las clases). Y finalmente si no encontramos allí el método que buscamos, recibimos un mensaje de error.

# Nuevos conceptos: Override y Super

Siguiendo con el ejemplo. el segundo tipo de ave es el petrel el cual
- come y vuela igual que un ave
- además el ornitólogo quiere registrar la cantidad de kilómetros que voló

OJO: en la realidad, el petrel vuela, el ornitólogo anota en un cuaderno las veces que voló, en nuestro modelo, el petrel no es el petrel, sino una representación del petrel que es mucho menos compleja, a la que le sacamos todas las características que no son esenciales mediante el proceso de abstracción.

Esto lo podemos implementar asi

```wollok
class Petrel inherits Ave {
	var kilometrosVolados = 0
	
	override method volar(kilometros) {
		super(kilometros)
		kilometrosVolados = kilometrosVolados + kilometros
	}
}
```

Ahora explicaremos el codigo

## Override
¿Por qué aparece la palabra override antes de method?

Porque la subclase (petrel)  está redefiniendo comportamiento de la superclase: ya teníamos una definición de volar(kilometros) pero nosotros queremos escribir otra, que va a pisar a la definición original de Ave.

entonces al enviar el mensaje VOLAR a una instancia de la clase petrel (unPetrel por ejemplo), el method lookup  comenzará a buscar en la clase receptora de la instancia unPetrel. Esto es... la clase Petrel, que ahora sí tiene una definición de volar.

## Super

Queremos aprovechar el comportamiento de volar() que está definido en Ave, pero sin repetir el código. Por eso utilizamos la pseudo-variable super:

Esto permite alterar el method lookup en el contexto en donde estamos, salteando la clase del objeto receptor y comenzando por su superclase . Esto es útil particularmente cuando estamos en un método redefinido y queremos evitar un loop infinito de llamadas al mismo método en el cual estamos.

Es decir, ejecuta el metodo de la super clase por eso en el ejemplo nuestro

```wollok
	override method volar(kilometros) {
		super(kilometros)
		kilometrosVolados = kilometrosVolados + kilometros
	}
```

super(kilometros) ejecuta el metodo volar de la superclase (no es super.volar porque ya esta adentro del metodo) y luego de ejectuar volar de la superclase ave, ejecuta la linea de abajo

### Ejemplo para entenderlo mejor

```wollok
class Animal {
  method saludar() {
    "Hola, soy un animal"
  }
}

class Perro inherits Animal {
  override method saludar() {
    super.saludar() + " y además soy un perro"
  }
}
```

el resultado final dira algo como *"Hola, soy un animal y además soy un perro"*

# Self

Para terminar estos ejemplos, tenemos la ultima ave la torcaza que
- vuela como un ave
- y al ser medio atolondrada, por un lado come igual que un ave pero antes de comer se pone tan contenta que vuela en círculos 1 kilómetro

Ya sabemos que si heredamos de Ave nuestra definición de volar() no debe cambiar, debemos redefinir el método comer().

```wollok
class Torcaza inherits Ave {
	
	override method comer(gramos) {
		energia = energia - (1 + 10) // copio el método volar, je
		super(gramos)
	}
}
```

Al comer, tenemos que hacer que vuele un kilómetro. Pero no queremos repetir el código de volar() dentro del método comer()

Lo que podríamos hacer es enviar el mensaje volar(1), pero ¿a quién? Al mismo objeto receptor, usamos para eso la referencia self:

```wollok
class Torcaza inherits Ave {
	
	override method comer(gramos) {
		self.volar(1)
		super(gramos)
	}
	
}
```
-usamos self para enviar mensajes al objeto receptor
- y cuando no podemos usar self, porque entraríamos en loop infinito, usamos super

## Method lookup del SELF

La diferencia está en que self no cambia el method lookup, que comienza por la clase del objeto receptor, mientras que super saltea el primer paso y comienza la búsqueda del método en la superclase de donde se invoca super

Si tenemos una instanciacion *unTorcaza* y le mandamos el mensaje comer se resuelve asi

```wollok	
override method comer(gramos) {
	self.volar(1)
	super(gramos)
}
```

1. El self volar al no estar definido en la clase torcaza, busca la definciion en la superclase ave y la aplica para el objeto unTorcaza
2. super(gramos) busca la definicion de COMER en la superclase ave y la aplica para el objeto unTorcaza

# Teoria

## Clase abstracta
Ave es una *clase abstracta:* tiene sentido como una forma de agrupar comportamiento y atributos para las subclases, no para generar instancias de Ave. 

- En algunos lenguajes esta definición es explícita: no podés crear una instancia de Ave si dijiste que era una clase abstracta. Al hacer new Ave() el compilador chequea que Ave no sea abstracta y en ese caso se produce un error. 

*public abstract class Ave { ... // Definición explícita en Java*

- En Wollok, esta definición ocurre naturalmente: si no hago new Ave(), esto implica que Ave termina siendo una clase abstracta, no hace falta decirlo.

## Herencia vs Composicion

La *herencia* marca una relación entre clases (es estática), la superclase tiene características más generales mientras que la subclase toma comportamiento específico y cuando es necesario lo redefine. 

En la *composición* no hay una jerarquía de clases, sino que intervienen dos instancias: una conoce a la otra y le envía mensajes.

se usa cuando un objeto contiene a otro como parte de su estado, es decir, "tiene un" en vez de "es un".

```wollok
class Motor {
  method encender() { console.print("motor encendido") }
}

class Auto {
  var motor = new Motor

  method arrancar() {
    motor.encender()
    console.print("auto en marcha")
  }
}
```

Un auto tiene un motor pero no es un motor.

¿Y por qué comparar la herencia con la composición? Supongamos que tenemos que modelar una Pila. La pregunta que nos tenemos que hacer es: ¿una pila es una lista? ¿o una pila tiene una lista?

Si Pila hereda de Lista, la ventaja es que toma todo el comportamiento de su superclase, y también allí radica su principal desventaja: quizás no sea necesario tener una interfaz tan grande, podríamos tener sólo tres métodos para la pila:
push(): pone un elemento de la pila
top(): muestra el elemento que está arriba de todo en la pila
pop(): saca el elemento que está arriba de todo en la pila

Entonces lo que nos conviene es que una Pila tenga una Lista, pero su implementación quede encapsulada en la Pila. El que utiliza a la Pila no necesita saber cómo está construida, simplemente utiliza los tres mensajes que definimos para la Pila.

Mediante la composición, permitimos que a futuro la Pila herede de otra superclase que tenga más cosas en común que una Lista, sin gastar el único tiro que la herencia provee.

# Codigo Final de los ejemplos

```wollok
// Superclase
class Ave {
	var energia = 50
	
	method volar(kilometros) {
		energia = energia - (kilometros + 10)
	}
	
	method comer(gramos) {
		energia = energia + gramos * 4
	}
}

// Ejemplo del inherits
class GolondrinaTijerita inherits Ave {
method hacerAlgo(conCosa) { ... }
}

//Override + Super
class Petrel inherits Ave {
	var kilometrosVolados = 0
	
	override method volar(kilometros) {
		super(kilometros)
		kilometrosVolados = kilometrosVolados + kilometros
	}
}

// Self
class Torcaza inherits Ave {
	
	override method comer(gramos) {
		self.volar(1)
		super(gramos)
	}
	
}
```