```wollok
```
# Mutabilidad/Inmutabilidad

Si queremos modelar un eje de coordenadas tenemos 2 decisiones de diseño posibles:
- hacer que el objeto sea mutable, definiendo setters para las propiedades(propertys) x e y
- construir un objeto inmutable. El punto, una vez construido, no puede variar: representa una ubicación en el plano y no puede representar otro punto más que ése.


¿Qué pasa si queremos sumar dos puntos? Se termina construyendo un punto nuevo...

```wollok
class Point {
  const property x
  const property y

  method +(otroPoint) = 
    new Point(x = x + otroPoint.x(), y = y + otroPoint.y())
}
```

Esto mismo se usa para:

- los números: tenemos un objeto 2 y otro que representa al 3, si los sumo el 2 no “cambia” a 5, el 5 es un nuevo objeto
- los strings, que son inmutables: cuando quiero concatenar dos strings, genero uno nuevo
- los booleanos, ya que en realidad existe un solo true y un solo false

# Value Objects

En general, todos los objetos que describimos recién entran en la categoría de Value Objects: son objetos que representan un valor de nuestro dominio.

Otros ejemplos posibles podrían ser: objetos que representan un color, como el rojo, un objeto que modela un mail, un objeto que representa una figura bidimensional (sería un value object construido como una lista de puntos),  una fecha, etc.

# Motivacion para objetos inmutables

*¿Por qué queremos tener objetos inmutables?*

Porque son objetos que no tienen efecto colateral: más allá de que el paradigma lo soporte, yo elijo no trabajar con este concepto, reforzando la idea de que el paradigma está en quienes desarrollan.

Al no tener efecto colateral
- el testing se simplifica, porque entran en juego una menor cantidad de situaciones y contextos
- es más fácil compartir los objetos en forma concurrente, porque sabemos que nadie puede hacer modificaciones a ese objeto

# Identidad

Si tenemos dos referencias idénticas, esto significa que están apuntando al mismo objeto.

*alumno --> OBJETO <-- luciano*

referencias identicas: alumno y luciano apuntan al mismo objeto

## Ejemplo

Consideremos una clase mail y creo una instancia de esa clase

```wollok
class Mail {
  const property asunto
  const property emisor
  const property receptor
}

//Creo en consola una instancia
const invitacion10Oct = new Mail(asunto = "Asado?", 
      emisor = "dodain@gmail.com", receptor = "alf@gmail.com")
      

// Si escribo esto
const unMail = invitacion10Oct
```
En el diagrama se ve que ambas referencias *unMail e invitacion10Oct* apuntan al mismo objeto *Mail*

*unMail --> Mail <-- invitacion10Oct*

Esto es lo que se conoce como identidad y podemos utilizar el mensaje === en Wollok para preguntar si dos referencias son idénticas:

> unMail === invitacion10Oct
> ✓ true

Basicamente la identidad es cuando 2 referencias apuntan al mismo objeto

# Igualdad

En la mayoría de los casos estaremos bien con esta definición. Pero a veces tendremos que cambiar la estrategia para determinar si dos referencias están representando al mismo objeto, aun cuando no se trate exactamente del mismo objeto. Este concepto se llama *igualdad*.

Si mandamos otro mail con el mismo asunto emisor y receptor es el mismo mail?

```wollok
const invitacion17Oct = new Mail(asunto = "Asado?", 
           emisor = "dodain@gmail.com", receptor = "alf@gmail.com")

> invitacion17Oct == invitacion10Oct
✓ false
```

No son identicas porque apuntan a objetos distintos, pero tampoco son iguales *PORQUE??*

por defecto la igualdad está funcionando igual que la identidad. ¿Entonces para qué me sirve tener igualdad e identidad por separado?  Dijimos que queremos definir cuando *dos objetos representan lo mismo*

Bueno, si redefinimos el método equals o == logramos lo que queremos. Por ejemplo, dos mails pueden ser iguales si tienen el mismo asunto, el mismo emisor y el mismo receptor. Redefinimos entonces el mensaje == en Mail:

```wollok
class Mail {
  const property asunto
  const property emisor
  const property receptor


  override method == (otroMail) = 
    asunto == otroMail.asunto() &&
    emisor == otroMail.emisor() &&
    receptor == otroMail.receptor()
}
```

Ahora si puedo diferencias entre identidad e igualda, porque aunque no referencien al mismo objeto representan al mismo objeto.

Es por esto que queremos diferenciar igualdad (==) de identidad (===). 
