Como vimos en el modulo 2, para poder acceder a la referencia de un objeto, éste debe definir accessors, en particular los getters y setters:

```wollok
object pepita {
 	var energia = 0
 	
 	method energia() = energia	   // GETTER
 
 	method energia(_energia) {    // SETTER
      	energia = _energia
 	}
 	method volar() {
      	energia = energia + 10
 	}
}
```

De esa manera, podemos desde otra entidad (otro objeto, un test o un programa) conocer el valor de la referencia energia para pepita:

# Problema 1 - Codigo boilerplate

```wollok
object dodge1500 {
 	var color = "bordó"
 	var kilometraje = 150000
	var conAire = false
const patente = "RVM 363"
const anioPatentamiento = 1979
}
```

Para poder definir los atributos, tuvimos que pensar qué referencias se pueden modificar y cuáles no

La segunda decisión que acompaña a los atributos, es qué tipo de accessors definiremos para cada uno:
- para las referencias const vamos a publicar solo los getters
- en el caso del aire y el color, podemos publicar tanto getters como setters
- y en el caso del kilometraje, podríamos publicar un setter, pero vamos a preferir escribir un getter y tener un método de negocio realizarViaje(kilometros) para que incremente el kilometraje.

```wollok
object dodge1500 {
 	var color = "bordó"
 	var kilometraje = 150000
 	var conAire = false
     	const patente = "RVM 363"
 	const anioPatentamiento = 1979
 	
 	method patente() = patente
 	method anioPatentamiento() = anioPatentamiento
 	method conAire() = conAire
 	method conAire(_conAire) { conAire = _conAire }
 	method color() = color
 	method color(_color) { color = _color }
 	method kilometraje() = kilometraje
 	method realizarViaje(kilometros) {
      	kilometraje = kilometraje + kilometros
 	}
}
```

La definición está llena de código boilerplate (secciones de codigo que estan repetidas en multiples lugares y casi sin variacion), no solo es tedioso de escribir,  sino que también se entremezcla con el código que verdaderamente nos importa, el que está asociado a decisiones del negocio.

# Propiedades (Property)

## Definicion

Una propiedad en Wollok permite explicitar un contrato específico para una referencia:
- si la referencia es variable (var), Wollok genera su getter y setter
- si la referencia es constante (const), Wollok genera el getter

La creación de los accessors es implícito, no se visualiza en el código ya que la idea es conservar únicamente el comportamiento definido por el negocio.

El mismo ejemplo de arriba quedaria asi

```wollok
object dodge1500 {
 	var property color = "bordó"
 	var kilometraje = 150000
 	var property conAire = false
const property patente = "RVM 363"
const property anioPatentamiento = 1979
 
method kilometraje() = kilometraje
	
 	method realizarViaje(kilometros) {
      	kilometraje = kilometraje + kilometros
 	}
}
```

Como no queremos publicar un setter para el atributo kilometraje, elegimos
- no aplicar el modificador property para kilometraje
- y definir manualmente un getter específico para kilometraje

## Property en constates

Ya lo dijimos pero es importante recordar que si una variable es property cuya referencia es constante, no tendremos setters, solo getters.

## Redefinir los accesors implicitos

En el caso de definir un método accessor propio, éste pisa el implícito que define la property, tanto para getters como para setters.

```wollok
object dodge1500 {
 	...
 	const property anioPatentamiento = 1979
 	
 	method anioPatentamiento() = anioPatentamiento + 1
}
```

Si consulto el año, lo que va a devolver es 1980, es decir mi definicion pisa la definicion implicita.

