```wollok
```

# Introduccion a Clases

Si tenemos objetos, donde cada uno representa un libro diferente pero todos tienen características similares. Cuando a cada libro le pregunte si es caro cada uno va a responder lo que corresponda según su precio. Es decir

Si implementos la idea seria algo asi

```wollok
object elPrincipito {
 	var property precio = 100
	method esCaro() = precio > 150
	method aumentar(aumento) { precio = precio + aumento }
}

object martinFierro {
  	var property precio = 100
	method esCaro() = precio > 150
	method aumentar(aumento) { precio = precio + aumento }
}

object elReinoDelReves {
 	var property precio = 100
	method esCaro() = precio > 150
	method aumentar(aumento) { precio = precio + aumento }
}
```

Lo que vemos es que si bien cada uno de los libros tienen un precio diferente, todos los libros tienen el mismo comportamiento para decir si es caro; también es la misma la forma de aumentar el precio. Para no tener código duplicado podemos definir una clase Libro donde esté definido el comportamiento de todo libro. Es decir

```wollok
class Libro {
	var property precio = 100
	method esCaro() = precio > 150
	method aumentar(aumento) { precio = precio + aumento }
}
```

De esta manera, toda la lógica que teníamos definida en cada uno de los objetos, como es igual para todos, podemos tenerla directamente en un solo lugar que es la Clase.

### Diagrama de clases UML

Si vemos la clase libre en un diagrama UML queda algo asi (lo hago a mano porque me da paja meter el png ahora)

```wollok
----------------------------------------
LIBRO
----------------------------------------
Precio "property": Number
----------------------------------------
aumentar(aumento: number): void
esCaro(): boolean
----------------------------------------
```

- arriba está el nombre de la clase
- en el medio las referencias, ya sean constantes o variables
- en el último compartimento escribimos los métodos 

# Clase e instancia

Una analogia para este ejemplo es ver la CLASE LIBRO como un molde vacio a partir del cual vamos a crear las instancias de diferentes libros

```wollok
class Libro {
	var property precio = 100
	method esCaro() = precio > 150
	method aumentar(aumento) { precio = precio + aumento }
}
```

## Consola

Para crear el objeto principito escribimos en consola

```wollok
> const elPrincipito = new Libro()
```

Para tener un nuevo libro creamos con new, una nueva instancia de la clase Libro. Por lo tanto la variable elPrincipito va a apuntar a una instancia de Libro.  

Y voy a poder decirle al principito que aumente de precio y preguntarle si es caro

```wollok
> elPrincipito.aumentar(80)
```

----elprincipito ----> *LIBRO* -----(precio)-----> *180*

# Estructura de un objeto

Al instanciar un objeto, éste tiene todas las referencias definidas en su clase, , solo que con sus valores particulares. En el ejemplo anterior, Libro define que todo libro tiene una referencia a precio.

El valor de cada libro es propio de cada instancia, por eso las referencias o atributos se llaman también variables de instancia.

# Method lookup de clases

Nuestros objetos ya no tienen comportamiento, sino que definimos esa responsabilidad en la clase. Debemos entonces cambiar nuestro mecanismo de method lookup.

que sucede si hacemos

> elPrincipito.esCaro()

elPrincipito no es un objeto que tenga comportamiento explícito. Es una instancia de una clase Wollok. Entonces vamos a buscar la definición a la clase a la que pertenece elPrincipito. Ahí vemos que existe una definición del método esCaro

Y se termina resolviendo para los atributos propios del objeto elPrincipito: como la referencia precio de este objeto apunta a 180, elPrincipito es un libro caro.

# Polimorfismo con clases

Supongamos que ademas de libros, hay DVDs y laminas, de todos los productos conocemos su precio, solo que se calculan de formas diferentes

```wollok
class DVD {
	var property precioMinuto = 10
	var property cantidadMinutos = 90

	method precio() = precioMinuto * cantidadMinutos
	method esCaro() = cantidadMinutos > 100
}

class Lamina {
	var property ancho = 29.7
	var property alto = 42
	var property material = new Material()

	method precio() = alto * ancho * self.precioBase()
	method esCaro() = self.precioBase() > 50
	method precioBase() = material.precio()
}
```
Si bien todos los productos definen un método precio(), el cálculo del precio es diferente para cada producto, ya sea libro, DVD o lámina. Como el comportamiento es diferente, necesitamos clases diferentes.

## DATO

self.precioBase() se refiere al objeto receptor del mensaje: una instancia de la clase Lamina. 

Si instanciamos por consola estas nuevas clases 

```wollok
const jurassicPark = new DVD()
const laGioconda = new Lamina()
```
De esta manera, ya están los objetos instanciados correctamente y se les puede enviar a cualquiera de ellos el mensaje precio(), aunque el comportamiento de cada método precio() sea diferente

```wollok
jurassicPark.precio()
laGioconda.precio()
```

# Tipos y polimorfismo
Un tipo es un conjunto de mensajes que entiende un objeto.

Hemos visto  que una lámina, un DVD y un libro son polimórficos, porque aunque cada uno conserva su propia implementación, quien le envía mensajes no nota la diferencia y es el que aprovecha ese beneficio:

```wollok
class Comprador {
 	method comprar(algo) {
if (algo.esCaro()) {
	...
```

Para hacer la pregunta esCaro(), la referencia a algo puede apuntar a 
- un libro
- un DVD
- una lámina
- o a cualquier otro objeto autodefinido (wko) o de una clase que implemente el método esCaro()

El comprador, entonces, ni siquiera necesita conocer al objeto exacto al que le está hablando. Solo necesita saber que le puede enviar el mensaje esCaro()

# Repaso: objetos anónimos, wko y clases

Ahora que incorporamos a las clases como una forma más de representar conceptos, podemos preguntarnos ¿cuándo conviene modelar a través de objetos anónimos, cuándo usar wko y cuándo clase?

- los objetos anónimos tienen un alcance acotado, por ejemplo un test, o la resolución de un requerimiento (un método y todo el encadenamiento de mensajes que sale de ese método). Lo mismo pasa cuando necesitamos construir un bloque para pasárselo a filter, o al map de una colección: el objeto que representa al bloque no tiene nombre y no nos importa que lo tenga, existe para resolver el requerimiento puntual.

```wollok
method taxistasLocales() = 
taxistas.filter { taxista => taxista.viveEn(zona) }
// las llaves encierran un objeto anónimo que representa el
// criterio de selección de un taxista (es un bloque)
```

- objetos autodefinidos o wko: son objetos conocidos, porque están representando un concepto de negocio dentro de la aplicación. Esto ocurre cuando un objeto tiene un comportamiento específico, y nos interesa modelarlo en forma separada de otros objetos. 

- por último, las clases son importantes cuando existen múltiples objetos que comparten comportamiento y no tiene sentido que los nombre por separado: 

el viaje que hice ayer en colectivo, se parece mucho al viaje de la semana pasada. Si solo difieren en la información que guardan las referencias, el comportamiento se debe ubicar en un solo lugar para no repetir la misma idea una y otra vez.

