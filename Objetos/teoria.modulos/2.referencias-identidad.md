- Interfaz es lo que un objeto publica para que otro objeto lo use (es el qué).
- Implementación es lo que un objeto encapsula para definir cómo se termina resolviendo un mensaje. 

# Estado

El estado de un objeto es básicamente la información que el objeto guarda en un momento dado.

en POO esa información se almacena en referencias que apuntan a otros objetos o a valores.


class Pajaro {
    var energia = 10
    var nombre = "Pepita"
}

energia y nombre son atributos (tambien llamados referencias), que forman parte del estado del objeto Pajaro.

Cada atributo tiene:

Un nombre (energia, nombre)

Un valor (10, "Pepita")

El conjunto de todos los atributos y sus valores define el estado actual del objeto.

Ademas, cuando un objeto conoce a otros objetos (tiene referencias a ellos), estas referencias también forman parte de su estado.

class Gato {
    var amigo = new Pajaro()
}

amigo es una referencia a otro objeto (Pajaro).

Ahora, el estado del Gato incluye información sobre quién es su amigo y, a través de esa referencia, se puede interactuar con él.

Resumen: el estado de un objeto no son solo números o textos, también incluye referencias a otros objetos con los que puede interactuar.

# accesors

Una buena práctica de POO es que solo los métodos del objeto puedan cambiar su estado.

class CuentaBancaria {
    var saldo = 1000

    method depositar(cantidad) {
        saldo = saldo + cantidad
    }

    method extraer(cantidad) {
        saldo = saldo - cantidad
    }
}

El saldo no se modifica directamente desde afuera; solo se puede cambiar usando los métodos depositar y extraer.

Esto protege al objeto de cambios inesperados y asegura que siempre cumpla ciertas reglas (por ejemplo, no dejar saldo negativo si lo controlamos en extraer).

Esta idea de que el estado solo se manipula a través de métodos del objeto es parte del encapsulamiento, un concepto clave de POO.

## Getter setter

Para ello existe cierto tipo de mensajes llamados accessors, cuyo fin es publicar la referencia (getter) o modificar dicha referencia (setter).

// getter
method energia() { return energia }

// setter
method energia(_energia) { energia = _energia }

El getter se define como un método de una sola línea, que devuelve algo.

El setter no, es un método que modifica el estado interno del objeto, no tiene necesidad de devolver nada.

# Referemncias wollok

Wollok tiene dos maneras de definir referencias

- variables (var): es una referencia que puede cambiar el objeto al que apunta

- valores (const): es una referencia fija a un objeto, que no puede cambiar (una vez inicializada no es válida una nueva operación de asignación)

var age = 10
age = 11
age = age + 1

const adultAge = 21
adultAge = 18  // ESTO DA ERROR

# Relaciones bidireccionales

Una relación bidireccional permite que ambos objetos puedan enviarse mensajes, pero requiere mantener ambas referencias sincronizadas.

object juan {
    var mascota
    method mascota(_mascota) { 
        mascota = _mascota
        mascota.duenio(self) // self hace referencia al propio objeto Juan
    }
}

object firulais {
    var duenio
    method duenio(_duenio) { duenio = _duenio }
}

// En la consola
> juan.mascota(firulais)

Desventaja: si enviamos el mensaje duenio directamente a la mascota, la referencia del dueño puede quedar sin definir.

# Compartir valores

Si varios objetos quieren interactuar con el mismo objeto, basta con pasar la misma referencia:

object tefi {
    method jugarCon(_mascota) {
        // lógica de juego
    }
}

object juan {
    method alimentarA(_mascota) {
        // lógica de alimentación
    }
}

// En la consola
> tefi.jugarCon(firulais)
> juan.alimentarA(firulais)

tanto juan como tefi jugan con el mismo objeto firulais

# Identidad

Cada objeto tiene una identidad única en el ambiente:
- Dos referencias son idénticas si apuntan al mismo objeto.

juan.mascota(firulais)
firulais.duenio(juan)

// juan y firulais.duenio apuntan al mismo objeto
console.print(juan == firulais.duenio) // true




