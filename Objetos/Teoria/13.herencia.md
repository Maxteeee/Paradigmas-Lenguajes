Continuamos con la clase 4 de github de la granja y los animales.

```wollok
class Comedero {
	const pesoMaximoSoportado
	// Nota: le puse un default para poder correr los tests de la parte 2
	// que para la mayor√≠a no es relevante
	var property racion = 1   
	
	method esUtilParaAtender(animal) =
		animal.tieneHambre()
			&& animal.peso() < pesoMaximoSoportado
			
	method atender(animal){
		if(animal.peso() > pesoMaximoSoportado)
			self.error("Demasiado pesado")
		animal.comer(racion)
	}
	
	method consumoEnergetico() = 20 * pesoMaximoSoportado
}
```
## Particularizacion

Ahora queremos hacer un comedero que tenga la MISMA LOGICA pero que sea recargable, tenga stocks de comida,etc.

En un comienzo podriamos declarar una clase nueva de comederorecargable y luego copiar los metodos tal cual de Comedero

```wollok
class ComederoRecargable {
	const pesoMaximoSoportado
	var property racion = 1

    var stockRaciones = 0 // NUEVO

    method tieneRaciones() = stockRaciones > 0  // NUEVO   

	method esUtilParaAtender(animal) =
		animal.tieneHambre()
			&& animal.peso() < pesoMaximoSoportado
			
	method atender(animal){
		if(animal.peso() > pesoMaximoSoportado)
			self.error("Demasiado pesado")
		animal.comer(racion)
	}
	
	method consumoEnergetico() = 20 * pesoMaximoSoportado
}
```

Esto andaria pero estamos copiando codigo y logica lo cual no tiene sentido, esto nos lleva al tema de ahora que es la HERENCIA

# Herencia

Lo que hace la herencia es que una clase herede el comportamiento (mismos atributos y metodos) que otra clase ademas de los nuevos que declare.

Tambien se puede hacer que un OBJETO herede una clase

**Con el comedero nos quedaria:**

```wollok
class comederoRecargable inherits Comedero {
    var stockRaciones = 0 

    method tieneRaciones() = stockRaciones > 0  
}
```

**Un comedorrecargable ES un comedero**

### Detalles utiles 
- Es una relacion entre 2 entidades
    a. subclase --> mas particular, seria el comedero recargable
    b. superclase --> mas general, seria el comedero normal
- Ya se explico pero los metodos y atributos definidos en la superclase los hereda la subclase --> no repetimos logica
- Si no explicitamos una superclase, hereda de OBJECT

## Metodo lookup en herencia

Lo que sucede aca es:
- La subclase usa un metodo 
- Primero lo busca en si misma, si no lo encuentra va a buscarlo a la superclase

# Redefinicion

Volvemos a mi definicion de comedero recargable

```wollok
class comederoRecargable inherits Comedero {
    var stockRaciones = 0 

    method tieneRaciones() = stockRaciones > 0  
}
```

Si vemos comedero tiene un metodo de consumoEnergetico que es igual a comederoRecargable, pero si yo ahora quisiera que para mis comederos recargables la logica detras del consumo sea otra, como se implementa? ---> Usando **OVERRIDE**

```wollok
class comederoRecargable inherits Comedero {
    var stockRaciones = 0 

    method tieneRaciones() = stockRaciones > 0  

    override method consumoEnergetico() = stockRaciones * 2
}
```
Este override, se podria decir que redifine lo que hace el metodo de mi superclase hace en una nueva logica. Es importante **USAR EL MISMO NOMBRE DE MENSAJE.**

## Lookup con redefinicion

Es la misma logica, primero busca el metodo en si mismo y luego en la superclase, como este nuevo metodo esta definido de vuelta en mi subclase va a usar esa definicion y no la de la superclase

## Nueva problematica --> SUPER

Supongamos ahora, el caso donde a esutilparaadenter (metodo definimo en la superclase comedero) queremos agregarle una nueva verificacion en los comederos recargables, una idea podria ser implementar esto.

```wollok
class comederoRecargable inherits Comedero {
    var stockRaciones = 0 

    method tieneRaciones() = stockRaciones > 0  

    override method esUtilParaAtender(animal) =
        self.tieneRaciones() &&
            self.esUtilParaAtender(animal)
}
```
Pero hay un problema, como vimos mediante el method lookup se va a quedar en un buicle infinito porque siempre va a ejectuar su esutilparacomer pero nunca va a ejectuar el esutilparacomer de la superclase que es el metodo que tiene la logica real.

**SOLUCION**: Agregar **SUPER**

```wollok
class comederoRecargable inherits Comedero {
    var stockRaciones = 0 

    method tieneRaciones() = stockRaciones > 0  

    override method esUtilParaAtender(animal) =
        self.tieneRaciones() &&
            super(animal)
}
```

Lo que hace SUPER es buscar el comportamiento del mensaje donde esta includo pero en la **SUPERCLASE** directamente, no busca primero en la SUBCLASE esto evita que se quede en bucle infinitamente.

Basicamente le dice al method lookup que arranca de "arriba"/superclase

### Aclaracion method lookup

Si tengo 3 clases A B C unidas a traves de herecnias de esta forma

> A <-- B <-- C

Si estoy en C y hago un **SUPER**, va a buscarlo en B porque esa es su SUPERCLASE, si no llegara a estar en B entonces luego iria a buscarlo a A.

Otro detalle capaz mas rebuscado, si tengo en C en metodo que no encuentra, va para B. Si ese metodo llama a otro metodo que no esta en B, **VUELVE** a C y de ahi arranca de vuelta.

Basicamente, el method lookup arranca de donde instancio mi variable cada vez, unicamente con SUPER hacemos el truquito de arrancar una arriba.

## Mas casos de redefinicion

Supongamos que tengo mi superclase y 2 subclases que apuntan a la superclase osea

> A <-- B y A <-- C

Siguiendo la logica de la granja, A es mamiferos B Y C son vacas y cerdos.

Si quiero implementar un metodo que al caminar un **mamifero** pierde peso en funcion del tiempo

```wollok
method caminar(tiempo){
    peso -= tiempo * self.pesoQuePierdenCaminando
}

method pesoQuePierdenCaminando() // METODO ABSTRACTO
```
Pero ese peso que pierden por hora, dependera de si es una vaca o un cerdo porque no pierden el mismo peso caminando entonces cada subclase B y C debera definir la logica por su cuenta. 


**IMPORTANTE:** Es necesario que la superclase agregue el metodo abstracto para definir unicamente el metodo aunque no haga nada

Ahora en la vaca por ejemplo hariamos un:

```wollok
override method pesoQuePierdenCaminando(){
    //LOGICA
}
```

### Clase abstracta (mamifero en mi ejemplo)

En Wollok poseen como minimo un metodo abstacto, el cual debera ser definido por sus sub-clases.

Es una clase que agrupa comportamiento y atributos para las subclases y que no puede ser instanciada. Si yo quiero hacer **"new mamifero"** no va a dejar porque va a decir que el metodo abstracto debe ser implementado (cosa que no hicimos en la superclase para el peso que pierden)

# Limitaciones de la herencia SIMPLE

- Solo se puede heredar de UNA SUPERCLASE, no heredar de 2
- Evitar heredad si no amerita
- Su contrapartida es la herencia multiple como en c++ que lleva a otros problemas
- Muchos lenguajes implementan mecanismos complementarios a la herencia simple, pero excede el campo de la materia.
