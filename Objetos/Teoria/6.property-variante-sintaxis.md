Para estos temas nuevos del 6 al 9 vamos a usar los ejemplos de la clase 2.

```wollok
object jerry {	
	var property velocidad = 1
	
	method acelerar(){
		velocidad = velocidad * 1.5
	}
	method peso() = 5
}
```

## Setter and Getter

En varios lenguajes para modificar o acceder a un atributo, necesitas tener un metodo definido capaz de modificar o cambiar su valor (setter) y uno para acceder al valor (getter)

Supongamos que tenemos un atributo velocidad al que queremos acceder pero a su vez modificar, deberiamos tener algo como

```wollok
Objet jerry{
    var velocidad = 1
    method velocidad(){
        return velocidad
    }

    method velocidad(_velocidad){
        velocidad = _velocidad
    }
}
```

Estos 2 metodos por separados cumplirian esa funcion pero wollok nos deja definir un metodo diferente

# Property

```wollok
var property velocidad = 1
```

Esto nos da un getter y un setter sin tener que declararlo como antes

## Como se usa?
Se usa como usariamos los metodos si los hubieramos declarado explicitamente

```wollok
>>> jerry.velocidad()
1
>>> jerry.velocidad(5)
>>> jerry.veocidad()
5
```

## Detalle importante

Si el dia de ma√±ana quiero definir otra forma de como se modifica la velocidad, o como la retorna puedo hacerlo. Lo que defina explicitamente va a tener mas precedencia que el metodo implicito que me da el property

## Variante: properys constantes

Si quiero definir algo como que el peso sea 5 puedo hacerlo de 2 formas

```wollok
method peso(){
    return 5
}
```

Y la otra forma seria

```wollok
const property peso = 5
```

En esta segunda forma se define el atributo y al definirse como property tambien nos dan el getter que seria lo mismo que implementamos arriba.

No hay setter porque es una constante. Ambas formas son validas.

# Sintaxis funcionalista

Lo metemos junto con el property porque no es algo que vaya a usar en lo personal, pero es un contenido necesario.


```wollok
method peso(){return 5}

method peso() = 5

```

- Ambas formas son equivalentes
- El = tiene la misma semantica que en Haskell
- *Solo para metodos de conslta de una sola linea*



