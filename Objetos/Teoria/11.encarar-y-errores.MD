CLASE 4 GITHUB

## Como arrancamos?

Hay que buscar los puntos de entrada, osea leer los requerimientos y empezar por uno.

Generalmente diria que es mejor empezar por los requerimientos de consulta, si necesitamos alguno de efecto en uno de consulta podemos simplemente declararlo y terminarlo mas tarde

## Encarar ejercicios

Hay que usar bien los conceptos de polimorfismo, encapsulamiento y delegacion

Si tenemos 2 objetos que interactuan (clase 4 github) la forma de implementarlo podria ser mejor que el objeto que este en el punto de entrada con la logica mas general sea el que llame a los otros objetos con logica mas particular

*Ejemplo*

```wollok
bebedero.atender(animal)
```

El bebedero solo atiende y hace logica por encima, lo que pasa es particular de cada animal y por eso nos conviene ponerlo asi

# Errores

## Excepcion vs Return

Si queremos demostrar, algo como "Debemos considerar que no debería ser posible atender en un comedero a animales que pesen más que lo que el dispositivo soporta."

Podemos plantearlo de 2 formas

```wollok
method atender(animal){
		if(animal.peso() > pesoMaximoSoportado)
			self.error("Demasiado pesado")
		animal.comer(racion)
	}
```
o

```wollok
method atender(animal){
		if(animal.peso() > pesoMaximoSoportado)
			return "Demasiado pesado"
		animal.comer(racion)
        return "ok"
	}
```

El *SELF.ERROR* termina el programa como un exit. En cambion el *RETURN* no.

La profe dice que las expceiojnes (self error) son buenas, porque al reventar el programa todos nos entermoas que fallo si no se pudo cumplir. EN cambio con el return capaz nadie se entera porque ni te leen la consola.




