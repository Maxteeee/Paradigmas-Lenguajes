# Wollok

## 1 A

Falso, no seria facil implementar nuevas cuentas, por cada nuevo tipo de cuenta deberiamos agregar otro IF lo que haria el codigo bastante ilegible y confuso de entender, ademas de costoso de expandir. Mas facil hubiera sido crear una clase cuenta y sub clases que sean los distintos tipos de cuenta, asi se podrian agergar o eliminar cuentas de forma mas sencilla


## 1 B

Verdadero, una vez que la primer cuenta elimina esos GB de espacio, pase lo que pase con la cuenta 2 (tanto si tiene espacio, como no) no va a afectar a la cuenta 1, la cual ya va a tener esos GB eliminados de su cuenta

## 2

```java
class Cuenta {
    var property tipo
    var property usuarioPrincipal
    var property horasConsumidas
    var property limiteHoras
    var property espacioConsumido
    var property limiteEspacio     
    var property perfiles

    method estado() {
        return "Tipo: " + tipo + ", Usuario: " + usuarioPrincipal
    }
    
    method reproducirContenido(horas){
        return "Contenido reproducido"
    }

    method descargarContenido(gb) 

}

class CuentaBasica inherits Cuenta {
    override method estado(){
        super()
        +", Horas restantes: " + (limiteHoras - horasConsumidas)
    }

    override method reproducirContenido(horas){
        if (horasConsumidas + horas > limiteHoras){
            return "No podes reproducir mas contenido este mes"
        }
        horasConsumidas += horas
    }

    override method descargarContenido(gb){
        return "Tu plan no permite descargas"
    }
}

```

Esta fue mi resolucion primera, hasta que me di cuenta que tenian que cambiar de tipo. Ahi es cuando pense en usar composicion y quedo asi

```java
class Cuenta {
    var property usuarioPrincipal
    var property tipo // Aquí va el objeto de composición
    var property horasConsumidas = 0
    var property espacioConsumido = 0
    var property limiteHoras = 100
    var property limiteEspacio = 50
    var property perfiles = []

    method estado() {
        return "Tipo: " + tipo.nombre() + ", Usuario: " + usuarioPrincipal + ", " + tipo.infoEspecifica(self)
    }

    method reproducirContenido(horas) {
        tipo.validarReproduccion(self, horas)
        horasConsumidas += horas
    }

    method descargarContenido(gb) {
        tipo.validarDescarga(self, gb)
        espacioConsumido += gb
    }
}

// Objetos de tipo (Composición)
object tipoBasica {

    method nombre() = "Básica"
    
    method infoEspecifica(cuenta) = "Horas restantes: " + (cuenta.limiteHoras() - cuenta.horasConsumidas())
    
    method validarReproduccion(cuenta, horas) {
        if (cuenta.horasConsumidas() + horas > cuenta.limiteHoras()) 
            self.error("No podés reproducir más contenido")
    }
    
    method validarDescarga(cuenta, gb) { self.error("Tu plan no permite descargas") }
}

object tipoPremium {
    method nombre() = "Premium"
    method infoEspecifica(cuenta) = "Espacio disponible: " + (cuenta.limiteEspacio() - cuenta.espacioConsumido()) + " GB"
    
    method validarReproduccion(cuenta, horas) { /* No tiene límite */ }
    
    method validarDescarga(cuenta, gb) {
        if (cuenta.espacioConsumido() + gb > cuenta.limiteEspacio())
            self.error("No hay suficiente espacio")
    }
}

```

# Haskell

## 1

```haskell
ana :: [Alimento -> Bool]
ana = [esBajoEnCalorias, tieneProteinas]
```
## 2 A

```haskell
tieneNutriente :: String -> Alimento -> Bool
tieneNutriente  nutrienteBuscado =
    elem nutrienteBuscado . nutrientes 
```

## 2 B

```haskell
ana :: [Alimento -> Bool]
ana = [esBajoEnCalorias, tieneNutriente "proteinas"]
```

El concepto que se aprovecha aca que no se aprovechaba en la definicion anterior es la aplicacion parcial.

Al pasarle tieneNutriente "proteinas" no obtenemos un Bool, sino una nueva función que "ya sabe" que tiene que buscar proteínas y queda esperando al Alimento para terminar el trabajo.

## 3 

A: Verdadero: La función cumple con el objetivo: filter recorre los alimentos y any verifica si al menos uno de los requisitos (funciones) se cumple para ese alimento.

B: Falso: Es altamente declarativa. Usa funciones de orden superior (filter y any) en lugar de bucles manuales o recursividad.

C: Verdadero: Nombres como f no dicen nada sobre la lógica de negocio.

D: Falso: Haskell usa Lazy Evaluation. Si la lista de alimentos es infinita, filter irá devolviendo resultados a medida que los encuentre. El programa solo no terminaría si intentaras imprimir la lista completa, pero sí podés obtener respuestas parciales (ej. con take 5).

Correcion de la funcion:

```haskell

alimentosElegidos :: [Alimento -> Bool] -> [Alimento] -> [Alimento]
alimentosElegidos requisitos = filter (cumpleAlguno requisitos)

cumpleAlguno :: [Alimento -> Bool] -> Alimento -> Bool
cumpleAlguno requisitos alimento = any ($ alimento) requisitos
```

# Prolog

## 1

La solucion no cumple, ya que no evalua si un autor se dedica unicamente a un genero literario, sino lo que hace es verificar que todsa las obras de la base de datos fueron escritas por ese autor.

## 2

```prolog
autorEspecifico(Autor):-
    esAutorDe(Autor, Obra),
    genero(Obra, Genero),

    forall(
        (esAutorDe(Autor, OtraObra), genero(OtraObra, OtroGenero)),
        Genero == OtroGenero
    ).

%% Otra solucion que sirve y tiene sentido

autorEspecifico(Autor):-
    esAutorDe(Autor, Obra),
    genero(Obra, Genero),

    forall(
        esAutorDe(Autor, OtraObra), 
        genero(OtraObra, Genero)
    ).

```

## 3

El concepto de orden superior aparece en el uso del predicado forall, el cual es de orden superior ya que espera oros predicados como argumentos para manipularlos.

El segundo concepto que aparece es el de inversibilidad, este se puede ver en los predicados generadores antes del forall, esto permite que prolog gracias al concepto de backtracking pueda recorrer todos los autores de la base de conocimiento. 

Si no estuvieran estos predicados y fuera directamente el forall, no seria inversible ya que no sabria con quien esta trabajando yno podria devolver nombres, perdiendo su capacidad de generar respuestas