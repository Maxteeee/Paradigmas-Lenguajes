# Prolog

## 1

No, la solución propuesta no cumple con el requerimiento 3. El problema está en la cuantificación. El enunciado pide que el atleta haya participado en todas las competencias requeridas. Sin embargo, la segunda regla de la solución propuesta solo verifica que exista al menos una competencia previa en la que haya participado.

## 2

El predicado puedeInscribirse(Atleta, Competencia, Fecha) no es completamente inversible tal como está escrito.

- Para el atleta es inversible. El predicado inscripcionGeneral(Atleta, ...) funciona como generador.
- Para competencia no, es inversible. Se utiliza dentro de un not(participo(Atleta, Competencia, _)) antes de haber sido instanciada por ningún generador. Prolog no puede "negar" algo que no conoce todavía.
- Fecha no es inversible tampoco, El predicado añosCalendarioTranscurridos solo es inversible para su tercer parámetro. Por lo tanto, requiere que tanto FechaInscripcion como Fecha tengan un valor concreto antes de ser llamado.

Para corregirlo: Es necesario agregar generadores para Competencia y asegurar que Fecha llegue con valor (o usar un generador de fechas si existiera) antes de las validaciones.

## 3 Correcion

Esta versión utiliza forall para asegurar que se cumplan todas las competencias previas y evita la repetición de lógica usando un predicado auxiliar.

```prolog
puedeInscribirse(Atleta, Competencia, Fecha):-
    inscripcionGeneral(Atleta, FechaInscripcion),
    esCompetencia(Competencia), % Generador para inversibilidad
    not(participo(Atleta, Competencia, _)),
    cumpleCondicionPrevia(Atleta, Competencia, FechaInscripcion, Fecha).

% Caso A: Inscripción reciente (menos de 1 año)
cumpleCondicionPrevia(_, _, FechaInscripcion, Fecha):-
    añosCalendarioTranscurridos(FechaInscripcion, Fecha, 0).

% Caso B: Inscripción antigua (requiere TODAS las previas)
cumpleCondicionPrevia(Atleta, Competencia, FechaInscripcion, Fecha):-
    not(añosCalendarioTranscurridos(FechaInscripcion, Fecha, 0)),
    forall(competenciaRequerida(Previa, Competencia), participo(Atleta, Previa, _)).

% Generador auxiliar de competencias para que sea inversible
esCompetencia(C) :- competenciaRequerida(_, C).
esCompetencia(C) :- competenciaRequerida(C, _).
esCompetencia(C) :- participo(_, C, _).
```

# Haskell

## 1

```haskell

-- Nota, en esta resolucion tomo que un atleta puede llevar solo 1 equipamiento pero que la competencia acepta varios equipamientos

type Requisito =  Atleta -> Competencia -> Bool

data Competencia = Competencia {
    requisitos :: [Requisito],
    nacionalidadesPermitidas :: [String],
    edadMinima :: Int,
    equipamientoPermitido :: [String]
}

data Atleta = Atleta {
    edad :: Int,
    nacionalidad :: String,
    equipamiento :: String
}


requisitoNacionalidad :: Requisito
requisitoNacionalidad atleta = 
    elem (nacionalidad atleta) . nacionalidadesPermitidas 

requisitoEdad :: Requisito
requisitoEdad atleta  =
    (edad atleta >=) . edadMinima 

requisitoEquipamiento :: Requisito
requisitoEquipamiento atleta  = 
    elem (equipamiento atleta) . -equipamientoPermitido 

```

## 2

Un ejemplo de una competencia que tenga los 3 requisitos seria una competencia asi

```haskell

competenciaNatacion :: Competencia
competenciaNatacion = Competencia {
    requisitos = [requisitoNacionalidad, requisitoEdad, requisitoEquipamiento],
    nacionalidadesPermitidas = [Argentina, Brasil, Uruguay],
    edadMinima = 20
    equipamientoPermitido = [Antiparras, Gorro]
}

```

## 3

```haskell
controlDeInscripcion :: [Atleta] -> Competencia -> [Atleta]
controlDeInscripcion atletas competencia =
    filter (cumpleTodo competencia) atletas

cumpleTodo :: Competencia -> Atleta -> Bool
cumpleTodo competencia atleta =
    all (\requisito -> requisito atleta competencia) (requisitos competencia)
```

## 4 

**Orden superior:** Lo usamos en el filter para delegar la lógica de qué atletas se quedan en la lista sin tener que escribir un bucle manual y en all para verificar que se cumplan todas las funciones de la lista requisitos de la competencia.

Sirve para aumentar la declaratividad, permitiéndonos enfocarnos en el "qué" queremos (filtrar atletas que cumplen todo) y no en el "cómo" recorrer las listas.

**Aplicacion parcial:** Lo usamos en en (cumpleTodo competencia): Al pasarle solo la competencia, obtenemos una función que solo espera al atleta. Esto es lo que nos permite usar cumpleTodo adentro del filter.

Permite reutilizar funciones genéricas para casos específicos de forma dinámica

**Composicion:** Mejora la expresividad del código, creando una "tubería" de datos que se lee de derecha a izquierda.

# Wollok

## 1 A

Falso, no es necesario que haya una clase visitante, aunque la lista de visitantes este vacia en la clase parque el programa no romperia al llamar al metodo para cobrar porque forEach no iteraria sobre literlmente nada. 

Yendo mas al grano, no hace falta que exista la clase visitante en si. Cualquier otro objeto o clase que entienda el mensaje pagarEntrada seria perfectamente valido para la solucion.

Rta mas formal: La afirmación es falsa. No es necesaria la existencia de una clase Visitante para incluir objetos en la lista o para que el sistema funcione. Wollok se basa en el Polimorfismo: el Parque puede interactuar con cualquier objeto que cumpla con la interfaz requerida (mensajes tarifa() y pagarEntrada()), sin importar su jerarquía de clases".

## B

Verdadero, cualquier clase u objeto que entienda el mensaje tarifa y pagar entrada va a poder responder a los metodos del parque, esto permite agregar muchos tipos de visitantes diferentes con sus propios calculos internos de como pagar

## C (gemini)

Si todos los visitantes simplemente descuentan dinero de una billetera propia, estarías escribiendo la misma línea de código en cada clase de visitante.

Cómo evitarlo: Podrías usar Herencia (una superclase Visitante con el método base) o Composición si el "medio de pago" fuera un objeto aparte.

## D 

Falso, el adulto directamente no va a poder cambiarse a otro tipo de pago. 

Rta seria: los visitantes están modelados como instancias de clases fijas (ej. Adulto, Ninio), un objeto no puede "mutar" de clase en tiempo de ejecución para convertirse en un PaseRapido.
Solución: Se necesita Composición (que el visitante tenga un pase o una tarjeta) para que el comportamiento cambie sin cambiar el objeto.

## E (Si es falsa, pero no es por eso.)

Falso, primero el parque le cobra y luego hace que el visitante pague. En caso de no poder pagar el parque en sus atributos internos ya se sumo la plata de la tarifa dejando todo en un estado inconsistente



# 2

```java
class Parque {
    const property visitantes = []
    var property saldo = 0

    method cobrarEntrada() {
        visitantes.forEach { v => self.cobrarleA(v) }
    }

    method cobrarleA(visitante) {
        // CORRECCIÓN 1.e: Primero paga el visitante, luego suma el parque
        const monto = visitante.tarifa()
        visitante.pagar(monto) 
        saldo += monto
    }
}

class Visitante {

    var property formaDePago 
    var property edad

    
    method tarifa() = calculadorDeTarifas.tarifaPara(self.edad())
   
    
    method pagar(monto) {
        formaDePago.procesarPago(monto) 
    }
}

object calculadorDeTarifas {
    method tarifaPara(edad) {
        if (edad < 13) return 50      // Niños
        if (edad >= 65) return 30     // Jubilados (Nueva regla)
        return 100                    // Adultos
    }
}

object efectivo {
    method procesarPago(monto) { /* No hace nada extra */ }
}

class TarjetaPrepaga {
    var property saldoTarjeta
    
    method procesarPago(monto) {
        const totalAContar = monto * 1.1 // 10% de recargo por servicio
        if (saldoTarjeta < totalAContar) self.error("Saldo insuficiente en tarjeta")
        saldoTarjeta -= totalAContar
    }
}

class PaseRapido {
    var property accesosDisponibles
    
    method procesarPago(monto) {
        if (accesosDisponibles < 1) self.error("No quedan accesos en el Pase Rápido")
        accesosDisponibles -= 1
    }
}
```

## 3

Para agregar nuevos tipos de edad , en la solucion anterior deberiamos repetir todo por 3. Osea si aparece un jubilado deberiamos crear 3 subclases nuevas por forma de pago (agradeciendo que no hay mas). En la nueva solucion basta con agregar como queremos clasificar la edad y la tarifa al objeto que se encarga de calcularlas.
