# Haskell

## 1 
### Codigo aux dado

```haskell
habilidades :: Persona -> [Habilidad] -- Las habilidades de una persona
sirve :: Problema -> Habilidad -> Bool -- Supongo habilidad sirve para x problema
```

### Implementacion

```haskell
podrianAyudar :: Problema -> [Persona] -> [Persona]
podrianAyudar problema personas =  filter (habilidadUtil problema) personas

-- Con aplicacion parcial
podrianAyudar problema =  filter (habilidadUtil problema) 

-- Con composicion
podrianAyudar =  filter . habilidadUtil problema

habilidadUtil :: Problema -> Persona -> Bool
habilidadUtil problema persona = any (sirve problema) (habilidades persona)

-- Con composicion
habilidadUtil :: Problema -> Persona -> Bool
habilidadUtil problema = any (sirve problema) . habilidades


```

## 2

1.Orden Superior
Es el concepto más importante de la solución. Una función es de orden superior si recibe otra función por parámetro o devuelve una función.Dónde se ve: En filter y en any.

Para qué se usó: * filter recibe a habilidadUtil problema (una función que devuelve Bool) para decidir qué personas quedan en la lista.any recibe a sirve problema para decidir si alguna habilidad de la lista cumple la condición.

Utilidad: Permite delegar el control. No escribimos el "cómo" recorrer la lista; usamos funciones genéricas y les pasamos el "qué" queremos evaluar.

2. Aplicación Parcial Haskell permite pasarle a una función menos argumentos de los que espera, devolviendo una función nueva "pre-configurada".

Dónde se ve: En sirve problema, habilidadUtil problema y filter (...).

Para qué se usó: * sirve espera un Problema y una Habilidad. Al hacer sirve problema, creamos una función nueva que solo espera la habilidad.Lo mismo pasa con filter: al no pasarle la lista de personas al final (en la versión point-free), obtenemos una función que espera esa lista para filtrar.

Utilidad: Permite crear funciones específicas a partir de funciones más generales de forma dinámica.

3. Composición de FuncionesEs el uso del operador punto para conectar la salida de una función con la entrada de otra.

Dónde se ve: En any (sirve problema) . habilidades y en filter . habilidadUtil.

Para qué se usó: * Para unir el proceso de "obtener datos" (habilidades) con el de "evaluar datos" (any).

Utilidad: Aumenta la declaratividad. El código se lee como una serie de transformaciones en una tubería (pipeline), eliminando la necesidad de variables intermedias innecesarias y haciendo el código más compacto.

## 3

Si entrara una persona con habilidades infinitas no habria problema, Haskell recorreria la lista de habilidades hasta encontrar una que sirva para el problema. Una vez encontrada dejaria de recorrer la lista y seguiria a la siguiente persona. Esto gracias al concepto de lazy evaluation donde haskell no evalúa las expresiones hasta que su resultado sea estrictamente necesario para continuar con la ejecución.

Como dato extra, la función any está implementada de forma que, apenas encuentra un valor que cumple la condición (True), deja de evaluar el resto de la lista

# Prolog

## 1

### Codigo aux dado

```prolog
tiene(Persona, Cosa).
vale(Cosa, Valor).
```

### Implementacion

```prolog
todoLoQueTieneEsMasValioso(Persona1, Persona2) :-

    % Predicados generadores
    tiene(Persona1, _),
    tiene(Persona2, _),

    forall(
        (tiene(Persona1, Cosa1), vale(Cosa1, ValorCosaValiosa), tiene(Persona2, Cosa2), vale(Cosa2, OtroValor)),
        ValorCosaValiosa > OtroValor
    ).

```

Yo antes habia hecho esta soluciones

```prolog
todoLoQueTieneEsMasValioso(Persona1, Persona2) :-

    tiene(Persona1, CosaUno),
    tiene(Persona2, CosaDos),

    forall(
        vale(CosaUno, ValorUno),
        (vale(CosaDos, ValorDos), ValorUno > ValorDos)
    ).

todoLoQueTieneEsMasValioso(Persona1, Persona2) :-

    tiene(Persona1, CosaUno),
    vale(CosaUno, ValorUno),
    tiene(Persona2, CosaDos),

    forall(
        vale(CosaDos, ValorDos),
        ValorUno > ValorDos
    ).


```

Explicacion de porque estan mal:
- En el primer ejemplo, al poner tiene(Persona1, CosaUno) afuera del forall, Prolog busca un objeto de la Persona 1. Si encuentra uno solo que sea más valioso que todos los de la Persona 2, el predicado da True.

- En el segundo, como CosaUno y CosaDos vienen instanciadas desde afuera del forall, el generador vale(CosaUno, ValorUno) solo se fija en el valor de esa cosa específica.

## 2 A

Si se puede hacer, para poder preguntar si "nadie cumple algo" usando not(todoLoQueTieneEsMasValioso(P1, P2)), el predicado interno debe ser capaz de generar o probar individuos.

Predicados Generadores: Lo que permite el uso es que el predicado todoLoQueTieneEsMasValioso esté construido con generadores externos (como tiene(Persona, _) o persona(P)). Estos generadores "instancian" las variables antes de que lleguen a la lógica de control.

Ligadura de Variables: Al estar las variables ligadas a un valor concreto, el motor de Prolog puede realizar una búsqueda exhaustiva. Si no fuera inversible, el not fallaría porque no sabría sobre qué "universo" de personas está negando.

### B

Y la consulta seria: ¿Es verdad que NO EXISTE alguien tal que todo lo que tiene sea más valioso que lo de pedro?

> ?- not(todoLoQueTieneEsMasValioso(_, pedro)).

# Wollok

## 1 A

Verdadero, si escribieramos el metodo el protanogista no es verano en la superclase, nos ahorrariamos escribir en cada subclase el mismo codigo repetido, bastaria con que llamen al metodo de la superclase para obtener la respuesta

## 1 B

Falso, en ningun momento se rompe el encapsulamiento, ninguna clase de pelicula accede a los atributos del personaje y lo modifica, unicamente hacen consultas para ver si son esteriotipados o no

## 1 C

Falso. Aunque es cierto que no hay ifs, la ausencia de condicionales no garantiza por sí sola un "buen uso" del polimorfismo. Aquí hay una falla de delegación: la película está "preguntándole" muchas cosas al personaje para tomar una decisión. Un mejor diseño polimórfico sería que el Personaje sepa si rompe estereotipos en base a su propia naturaleza, evitando que la película tenga que conocer tantos detalles internos del protagonista.

## 2 

```wollok

ZZZZZZZ es unicamente las 2 primas condiciones meterlas en la superclase, y en las subclases llamarlas con self o super

```