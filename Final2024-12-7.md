# Haskell

### Codigo ya  dado

```haskell
data Videojuego = UnVideojuego {
titulo :: String,
desarrolladora :: String,
generos :: [String],
lanzamiento :: Int
}

esDesarrolladoPor dev = (==dev).desarrolladora

perteneceAGenero genero videojuego = elem genero (generos videojuego)

esReciente videojuego = lanzamiento videojuego > 2015
```

## 1 A

```haskell

type Jugador = Videojuego -> Bool

juan :: Jugador
juan videojuego = 
    esDesarrolladoPor "Nintendo" videojuego || perteneceAGenero "Plataformas" videojuego

maria :: Jugador
maria = esReciente 

pedro :: Jugador
pedro videojuego =
    esDesarrolladoPor "Rockstar Games" || perteneceAGenero "Mundo abierto"
```

## B

```haskell
preferidosDelComite :: [Jugador] -> [Videojuego] -> [Videojuego]
preferidosDelComite jugadores videojuegos = filter (gustaATodos jugadores) videojuegos

gustaATodos :: [Jugadores] -> Videojuego -> Bool
gustaATodos jugadores videojuego = all (\unJugador -> unJugador videojuego) jugadores

```

Explicacion: 
- Expresión Lambda (\unJugador -> ...): La usamos dentro de all. ¿Por qué? Porque all espera una función que reciba un elemento de la lista (en este caso, un Jugador) y devuelva un Bool. Como el Jugador es a su vez una función, necesitamos la lambda para decirle: "Tomá este jugador y aplicalo al videojuego que estamos evaluando".

- Aplicación Parcial: En filter (leGustaATodos jugadores), estamos aplicando parcialmente leGustaATodos. Al pasarle solo la lista de jugadores, nos devuelve una nueva función que espera un Videojuego, que es exactamente lo que filter necesita para trabajar sobre la lista de juegos. Osea filter espera de A -> Bool que es lo que nos queda al aplicar parcialmente

## 2
La principal utilidad en este ejercicio es la flexibilidad y la reutilización de código. Se nota en tres puntos:

- Separación de tareas: Gracias a filter y all, no tenemos que escribir nosotros el código para recorrer las listas (sin bucles ni recursión). Nosotros solo definimos el qué (la condición) y las funciones de orden superior se encargan del cómo (el recorrido).

- Los jugadores como "lógica móvil": Al tratar a los jugadores como funciones, podemos guardarlos en una lista y pasarlos por parámetro. Esto permite que el comité sea dinámico: podemos agregar o sacar jugadores sin tener que modificar nunca la función preferidosDelComite.
## 3

```haskell
-- Tipos de datos
esDesarrolladoPor :: String -> Videojuego -> Bool
esDesarrolladoPor dev = (==dev).desarrolladora

perteneceAGenero :: String -> Videojuego -> Bool
perteneceAGenero genero videojuego = elem genero (generos videojuego)

esReciente :: Videojuego -> Bool
esReciente videojuego = lanzamiento videojuego > 2015
```

# Objetos 

## 1 A y B

```java
// A
class Jugador {
    method prefiere(videojuego)
}

object Juan inherits Jugador {

    override method prefiere(videojuego){
        videojuego.desarrolladora() == "Nintendo" || 
        videojuego.generos().contains("Plataformas") // Contains porque es una LISTA de generos
    }
}

object Maria inherits Jugador {

    override method prefiere(videojuego){
        videojuego.año() > 2015
    }
}

object Pedro inherits Jugador {

    override method prefiere(videojuego){
        videojuego.desarrolladora() == "Rockstar Games" || 
        videojuego.generos().contains("Mundo abierto")
    }
}

// B
class Comite {
    var jugadores = []

    method preferidosDelComite(videojuegos){
        videojuegos.filter({ unJuego => self.todosLoPrefieren(unJuego) })
    }

    method todosLoPrefieren(videojuego){
        jugadores.all({jugador => jugador.prefiere(videojuego)})
    }
}
```

## 1 C

Los objetos que se ven involucrados son:
- Receptor: Una instancia de la clase Comite. Es quien coordina la lógica global del proceso.
- Parámetros: Una colección de objetos Videojuego. Es el conjunto sobre el cual se aplica el filtro.
- Colaboradores internos: La colección de objetos Jugador (como juan, maria y pedro) que el comité conoce internamente. Ellos son los encargados de decidir si prefieren o no un juego individual.

## 1 D

Es posible incorporar este nuevo jugador sin tocar una sola línea del código del Comite ni de los otros jugadores. Esto se debe al concepto de polimorfismo. El Comite no sabe (ni le interesa) cómo un jugador decide su preferencia. El único requisito es que el objeto jugador respete el contrato: entender el mensaje prefiere(videojuego) y devolver un booleano.

Esto permite extender la funcionalidad del sistema (agregar nuevos tipos de jugadores) sin alterar el código existente, manteniendo el sistema abierto a la extensión pero cerrado a la modificación.

## 2 

```java

class ComiteExigente inherits Comite {

    var property generosDestacados = []

    override method preferidosDelComite(videojuegos){
        super.preferidosDelComite(videojuegos) 
        videojuegos.filter({ UnJuego => self.cumpleConGenerosDestacados(unJuego)})
    }

    method cumpleConGenerosDestacados(videojuego){
        videojuego.generos().count({ genero => generosDestacados.contains(genero) }) >= 2
    }
}

```

## 3

Los conceptos del paradigma que se aplicaron a la solucion anterior fueron los siguientes
- Polimorfismo: Es el concepto estrella de esta solución. Se ve reflejado en la relación entre el Comité y los Jugadores.

El método todosLoPrefieren del comité recorre una lista de objetos (jugadores) y les envía el mensaje prefiere(videojuego). Destaca porque El comité trata a todos los jugadores por igual, sin importarle si son instancias de Juan, Maria o Pedro. Esto permite que el comité sea extensible: podés agregar nuevos tipos de jugadores y el código del comité no cambia ni una coma.

- Herencia y redefinicion de metodos: Se utiliza para organizar la jerarquía de los evaluadores y para especializar el comportamiento del comité, se puede ver enEn los Jugadores: Juan, Maria y Pedro heredan de Jugador y redefinen el método prefiere para implementar su propia lógica de negocio O en ComiteExigente que hereda de Comite y redefine preferidosDelComite.

Gracias a estos conceptos podemos definir un contrato común (la clase Jugador) y garantiza que todos los subtipos respeten la misma interfaz, facilitando el polimorfismo mencionado antes.

- Delegacion: En lugar de que el Comité intente adivinar qué le gusta a cada uno, le "pasa la pelota" al que sabe. El Comite delega la responsabilidad de la evaluación en los objetos Jugador.

Mantiene la cohesión alta. El comité solo se encarga de coordinar la votación (lógica global), mientras que cada jugador es el "experto" en su propia preferencia (lógica local).

- Encapsulamiento: Cada objeto protege su lógica interna y sus datos. Los criterios específicos de Juan (como que le guste Nintendo) están encerrados dentro de su clase. El comité no tiene idea de por qué a Juan le gusta un juego, solo recibe el resultado (true/false). Esto reduce el acoplamiento entre las clases: si Juan cambia de opinión y ahora prefiere Sega, solo tocás la clase de Juan y nada más.

# Logico

## Codigo para la base de conocimientos

```prolog
% videojuego(titulo, desarrolladora, [generos], lanzamiento).
```

## Resolucion

```prolog

% 1

jugador(juan).
jugador(maria).
jugador(pedro).

prefiere(juan, Titulo):-
    videojuego(Titulo, nintendo, _, _).

prefiere(juan, Titulo):-
    videojuego(Titulo, _, Generos, _),
    member(plataformas, Generos).

prefiere(maria, Titulo):-
     videojuego(Titulo, _, _, Lanzamiento),
     Lanzamiento > 2015

prefiere(pedro, Titulo):-
    videojuego(Titulo, rockstarGames, _, _).

prefiere(pedro, Titulo):-
    videojuego(Titulo, _, Generos, _),
    member(mundoAbierto, Generos).

% 2

preferidosDelComite(Titulo):-
    videojuego(Titulo, _, _, _),

    forall(
        jugador(Jugador)
        prefiere(Jugador, Titulo)
    ).

% 3

ovejaNegra(Titulo):-
    videojuego(Titulo, _, _, _),

    forall(
        jugador(Jugador),
        not(prefiere(Jugador, Titulo))
    ).

```

## 4

Tanto ovejaNegra como preferidosDelComite son completamente inversibles ya que ambos cuentan con un predicado generador al comienzo el cual permite que la variable se instancie antes de entrar al forall. Gracias al concepto de backtracking prolog va a probar todas las soluciones posibles.

**Ejemplos de consulta:**

- Para verificar: ? preferidosDelComite(marioKart). (Devuelve true o false).
- Para generar: ? preferidosDelComite(Cual). (Devuelve Cual = marioKart, Cual = zelda, etc.).

- Para verificar: ? ovejaNegra(superman64). (Devuelve true si a nadie le gusta).
- Para generar: ? ovejaNegra(JuegoMalo). (Devuelve todos los títulos que nadie prefiere).