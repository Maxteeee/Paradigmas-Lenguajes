# TEMAS
Variables. Consultas Existenciales. Reglas simples y compuestas. Inversibilidad.


# Variables


Volviendo al ejemplo de las pastas


```prolog
pastas(ravioles).
pastas(fideos).
```


No solo podemos preguntar si los fideos o los ravioles son pastas, sino que tambien podemos preguntar que pastas hay en nuestra base de conocimientos.


```prolog
? pastas(Pasta).
Pasta = ravioles _


```


La diferencia es quie Pasta comienza con mayuscula,  entonces en lugar de trabajar con un individuo, la consulta se hace con una variable o incógnita.


Esto significa que no conocemos los individuos que satisfacen la relación pastas/1, y los queremos determinar.


Se puede leer como “¿Cuáles son los individuos que satisfacen el predicado pastas/1?”


## Variables anonimas


Si nuestro objetivo es determinar si existe alguna pasta, sin importar cuáles son las pastas concretas que forman parte del universo, la consulta se puede escribir así:


```prolog
? pastas(_).
true
```


Esto implica que debe existir al menos un individuo que satisfaga la relación pastas/1. Cuando no nos importe unificar el valor de un individuo que participa de un predicado con una variable, utilizamos el caracter guión bajo (_) y lo llamamos variable anónima.


# Multiples soluciones


En este caso el motor de inferencia Prolog no solo puede inferir si una relación se satisface para ciertos individuos, sino también cuál es el universo de individuos que cumplen una relación. Solo que lo hace un individuo a la vez, por eso aparece el guion bajo luego de ravioles


```prolog
? pastas(Pasta).
Pasta = ravioles _
```


Para que siga buscando le damos al enter


```
? pastas(Pasta).
Pasta = ravioles ;
Pasta = fideos _
```


Si tenemos esta otra base


```prolog
come(juan, ravioles).
come(melina, ravioles).
come(brenda, fideos).
come(juan, fideos).
```


Podemos consultar  quiénes comen ravioles:


```prolog
? come(Persona, ravioles).
Persona = juan ;
Persona = melina ;
false
```


o que comidas come juan


```prolog
? come(juan, Comida).
Comida = ravioles ;
Comida = fideos ;
false
```


**Nota: El false se puede leer como “no fue posible encontrar más individuos que satisfagan la relación"**


Esta es una característica interesante de Prolog, que nos permite hacer consultas donde en cada argumento pasemos
- **individuos**, en ese caso se dice que están instanciados
- o **variables**, en ese caso se dice que están libres


## Tipos de consulta


Hay  2 tipos de consultas


1. aquellas en las que queremos determinar si una relación específica se satisface o no, instanciando todos los argumentos:


```prolog
? come(juan, ravioles).
? pastas(bohio).
```


esto se verifica o no (true or false)


2. las consultas existenciales, permiten conocer si existen individuos que satisfacen una relación, en ese caso alguno de los argumentos debe estar libre (debe ser una variable).


```prolog
? pastas(_).
true.
```


o mas interesante aun saber quienes cumplen


```prolog
? come(juan, Comida).
? come(Persona, Comida).
? pastas(Pasta).
```


# Inversibilidad


Decimos que un predicado es inversible cuando admite consultas con variables libres para sus argumentos: en el caso de los hechos no hay restricciones así que tanto come/2 como pastas/1 son totalmente inversibles.


Más adelante veremos que no siempre es posible hacer consultas existenciales para todos los argumentos, en ese caso tendremos predicados que serán inversibles para el primer, segundo o cuarto argumento.




# Reglas


Los predicados que escribimos hasta el momento de pastas, se los conoce como **HECHOS** y se consideran axiomas: cuando hacemos la consulta come(juan, ravioles) el motor de inferencia asume que si existe un hecho escrito en la base de conocimientos, éste se cumple.


```prolog
come(juan, ravioles).
come(melina, ravioles).
```


Prolog también permite trabajar con otro tipo de predicados más interesante: las **reglas**


Una regla tiene
- uno o más antecedentes
- un consecuente


Si se cumplen los antecedentes, entonces se satisface el consecuente. Lo que en lógica se escribe p => q, en sintaxis PROLOG se escribe al revés:


**q :- p.** para que se entienda mejor **consecuente :- antecedente(s).**


En resumen: Si se cumplen los antecedentes, entonces se cumple el consecuente. Esta forma de escribir los predicados se llama cláusula de Horn.




### Ejemplo:


```prolog
humano(socrates).
mortal(Persona):-humano(Persona).
```


Del ejemplo vemos que hay 2 consecuencias


1. un predicado puede ser


   -   un hecho: no tiene antecedentes y se considera cierto porque está escrito en la base de conocimientos


   - o una regla: tiene al menos un antecedente y se satisface para un individuo si éste cumple todos los antecedentes


2. no tiene sentido escribir mortal(socrates) porque esa información se puede inferir a partir de la base de conocimientos. Aquí empieza a verse alguna de las ventajas de trabajar en el paradigma.


# Declaratividad


No hay estructuras de control en nuestra base de conocimiento, solo reglas y hechos que permiten a Prolog inferir conocimiento.


Nos posicionamos como usuarios de ese motor, y nos basta saber que si incorporamos a la base de conocimientos


```prolog
humano(platon).
```


Cuando hagamos la consulta


```prolog
mortal(Persona).
```


tendremos ahora dos individuos que satisfagan esa relación


```prolog
Persona = socrates
Persona = platon
```
##  Unificacion


Cuando hacemos la consulta y aparece


```prolog
mortal(Persona).
Persona = socrates
Persona = platon
```


No hay una asignacion de variable,  en Prolog no existe el concepto asignación, sino unificación: donde en este caso una variable se resuelve como incógnita con uno o más valores.


Persona es la incógnita, socrates y platon son los valores


Pero es importante recalcar que las consultas no devuelven nada: pueden satisfacerse o no, puedo encontrar los individuos que cumplen un predicado, pero de ninguna manera un predicado “devuelve” valores. No puedo pensar un predicado cómo una expresión, como si estuviera en una solución imperativa, solamente puedo seguir construyendo reglas para unificar esos valores y hacer más preguntas.


# Reglas compuestas


## AND
Si contamos con esta base de conocimientos


```prolog
viveEn(tefi, lanus).
viveEn(gise, lanus).
viveEn(alf, lanus).
viveEn(dodain, liniers).
docente(alf).
docente(tefi).
docente(gise).
docente(dodain).
```


y queremos expresar que cualquier docenete que vive en lnaus es afortunado, vemos que tiene que vivir en lanus **Y** ser docente, esto se expresa en prolog separando los antecedente con una **coma**


```prolog
afortunado(Persona):-docente(Persona), viveEn(Persona, lanus).
```


Persona es una variable, que se unifica para docente/1 y viveEn/2. Cuando se verifica docente(alf), se busca satisfacer viveEn(alf, lanus), con éxito.
          
En cambio para el caso docente(dodain) no se cumple viveEn(dodain, lanus), por lo que la regla compuesta afortunado(dodain) no se cumple. 


ENTONCES
- la variable Persona se unifica para todos los individuos que satisfacen docente/1.
- una vez unificada la variable, al tratar de satisfacer viveEn/2 ya no hay incógnitas: Persona es un valor conocido (INSTANCIADO), aquel que encontramos como una solución posible de docente(Persona), y lanus es un individuo.


## OR


“Si una persona es docente o vive en Lanús es afortunada”


Esto en prolog se expresa repitiendo las clausulas con dos reglas diferentes


```prolog
afortunado(Persona):-docente(Persona).
afortunado(Persona):-viveEn(Persona, lanus).
```


Entonces por cualquiera de las dos ramas que cumpla el antecedente docente/1 o viveEn/2, la regla afortunado/1 se satisfará.



















