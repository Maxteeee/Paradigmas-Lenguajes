# TEMAS
Estructuras de datos. Individuos simples y compuestos


# Individuos


```prolog
pastas(ravioles).
come(juan, fideos).
```


ravioles, juan, fideos marcan lo que conocíamos hasta el momento como un individuo, que es un tipo de dato simple: es atómico, no se puede descomponer en otros elementos.


## Numeros


Los números se utilizan como literales:


```prolog
ingrediente(1, pollo).
nota(salvatelli, 8).
```


En este caso tenemos 1 y 8 como valores literales. Los números, además de poder compararse por igualdad/desigualdad definen
- operadores aritméticos: la suma (Valor + 2), la resta (Valor - Monto), la multiplicación (3 * 4), la división (Numero / 2), el valor absoluto (abs(-2)), entre otros
- operaciones de comparación por orden: <, =<, >, >=


### IS/2


Ahora bien, si pensamos en una regla que relacione un número con su valor siguiente, tenemos que pensar en esta regla, donde siguiente es N+1, pero no podemos escribirlo asi


```prolog
siguiente(Valor, Siguiente):- Siguiente = Valor + 1.
```


Porque compara expresiones, de hecho en consola vemos que ocurre eso


```prolog
? 5 = 2 + 3.
false // el número 5 no es igual a la expresión 2 + 3


? 2 + 3 = 3 + 2.
false // la expresión 2 + 3 no es igual a la expresión 3 + 2


? 2 + 3 = 2 + 3.
true // son las mismas expresiones
```


Entonces para resolver la regla siguiente/2, debemos usar el operador **IS**, que relaciona un número (del lado izquierdo) con una operación (del lado derecho) que se evalúa.


**Num is Operacion**


Pueden probar estas consultas:


```prolog
? 4 is 2 * 2.
true // se puede unificar 4 a la expresión evaluada 2 * 2


? 4 is 24 - 6.
false // 4 no es unificable a 18


? Z is 2 * 2.
Z = 4 _ // existe un individuo que satisface la operación 2 * 2, que se evalúa como 4
```


Definimos entonces el predicado siguiente/2:


```prolog
siguiente(Valor, Siguiente):- Siguiente is Valor + 1.
```


Esto nos permite hacer estas consultas:


```prolog
? siguiente(2, 3).
true


? siguiente(4, Numero).
Numero = 5 _
```


Pero no podemos dejar variables sin ligar del lado derecho de una expresión en el operador is/2:


```prolog
? siguiente(Numero, 4)
ERROR: is/2: Arguments are not sufficiently instantiated
```


## Strings


También podemos trabajar con cadenas de caracteres, sobre todo cuando necesitamos modelar un individuo que tiene espacios:


```prolog
escritor("Jorge Luis Borges").
escritor("Julio Cortázar").
escritor("Elsa Bornemann").
```


# Individuos compuestos - Listas
Las listas representan una serie de elementos ordenados, que pueden repetirse.


- [] representa una lista sin elementos, o lista vacía


- [borges] representa una lista con un solo elemento


- [1, 4, 9, 10] representa una lista con 4 elementos, donde el primer elemento es 1


- En una lista pueden convivir todo tipo de individuos: [8, hermanos, 6.0, "jeje"] aunque hay que ver qué hacemos con una lista así


## Recursividad


La lista es una estructura recursiva definido de la siguiente manera:
- el caso base es la lista vacía, que se denota [ ]
- el caso recursivo es una lista con al menos un elemento, que se divide en el primer elemento o cabeza y el resto llamado cola, que es una lista (aquí vemos la definición recursiva). Se denota con el patrón: [Cabeza|Cola]


Igual esto se vera a detalle en el modulo 5


## Functores


```prolog
nacio(karla, fecha(22, 08, 1979))


compro(cliente(231024, "Nelson Pedernera"), producto(pirufio, 239, 1)).
```


nacio/2 es un predicado que relaciona dos átomos: karla que es un individuo simple, y fecha/3 que es un functor de aridad 3.


UN FUNCTOR
- no es un predicado, si bien tienen formatos similares el functor no tiene un valor de verdad, no puedo preguntar ?- fecha(22, 08, 1979).


- tiene un nombre y una aridad que es la cantidad de individuos que lo componen


- es especialmente útil cuando necesitamos trabajar elementos heterogéneos, que tienen algo común pero diferente información entre sí


### Pattern matching con functores


```prolog
?- valor(fecha(20, 2, 1988), Valor).
Valor = fecha(20, 2, 1988).
```


Además, podemos usar pattern matching sobre los átomos de un functor. Si tenemos este predicado:


```prolog
nacio(karla, fecha(22, 08, 1979)).
nacio(sergio, fecha(14, 10, 1986))
```


Podemos consultar quién nació en 1986:


```prolog
?- nacio(Quien, fecha(_, _, 1986)).
Quien = sergio.
```


O en qué año nació alguna persona:


```prolog
?- nacio(_, fecha(_, _, Anio)).
Anio = 1979 ;
Anio = 1986.
```


Lo que no se puede hacer es  tratar de relacionar como variable el nombre del functor:


```prolog
?- nacio(_, Functor(_, _, Anio)).  // no funciona Functor
```

















