# TEMAS

Elementos de Diseño. Delegación. Acoplamiento. Code smells.

# Elementos de diseño

Dentro del paradigma logico

- los componentes se implementan mediante predicados e individuos

- ¿qué responsabilidad tiene un componente? para member/2 relacionar un elemento que pertenece a una lista, para forall/2 determinar si todos los individuos que cumplen un predicado satisfacen otra condición

# Acomplamiento

El acoplamiento es el grado en que los componentes se conocen.Para explicarlo volvamos al predicado que resuelve cuándo un alumno terminó un año:

```prolog
terminoAnio(Alumno, Anio):- 
	forall(materia(Materia, Anio), aprobo(Alumno, Materia)).

aprobo(Alumno, Materia):-nota(Alumno, Materia, Nota), Nota >= 6.
```

Si hablamos de componentes

> terminoAnio/2 --> Forall/2 ---> Conoce a materia y aprobo 

> Ademas aprobo/2 --> nota/3

Hay acoplamiento entre terminoAnio/2 y los predicados materia/2 y aprobo/2. Este acoplamiento es buscado y necesario para poder resolver nuestro requerimiento. Y a su vez, el predicado aprobo/2 se basa en el hecho nota/3:


Si la forma de modelar las notas cambia y queremos incluir los aplazos, de

```prolog
nota(raul, pdp, 9).
nota(herminio, pdp, 6).

% pasamos a

nota(raul, pdp, [9]).
nota(herminio, pdp, [2, 2, 6]).
```

¿Qué predicados debemos cambiar en nuestra solución?
aprobo/2, para considerar solamente la última nota:

```prolog
aprobo(Alumno, Materia):-
    nota(Alumno, Materia, Notas), 
    last(Notas, Nota), 
    Nota >= 6.
```

No es necesario cambiar el predicado terminoAnio/2, ya que aprobó no cambió los individuos con los que trabaja:

# Code smells

Los code smells son señales de que nuestra solución -aun funcionando- debería mejorarse. ¿Cómo? Incorporando abstracciones faltantes, utilizando conceptos más adecuados para construir una solución, haciendo que el código acepte soluciones más generales o sea más expresivo, proceso que se suele llamar refactorización. 

Para bajar a tierra esto que acabamos de decir, vamos a ver ejemplos concretos.

## Not vs Forall

Es siempre mejor usar forall..

```prolog
% Base compuesta por sigueA(Alguien, Alguien).

todosSiguenA(Rey):-
	personaje(Rey),
	not((personaje(Personaje), not(sigueA(Personaje, Rey)))).
```

Es inversible, pero no es tan facil de entender "“todos siguen a un personaje si no existe otro personaje que no lo siga a él”." En lugar de usar esta doble negacion es mas facil usar un forall que diga “todos siguen a un personaje si ... todos los personajes siguen a ese personaje”

```prolog
todosSiguenA(Rey) :-
	personaje(Rey),
	forall((personaje(Personaje), sigueA(Personaje, Rey))).
```

## Evitar duplicidades

Una ciudad es interesante si es antigua y tiene más de 10 puntos de interés copados

- un bar es copado si tiene más de 4 variedades de cervezas

- un museo de Ciencias Naturales es copado

Primera definicion

```prolog
baresCopados(Ciudad, Bares) :-
	findall(bar(CantVarCer), (puntoDeInteres(bar(CantVarCer), Ciudad), CantVarCer > 4), Bares).

museosCopados(Ciudad, Museos) :-
	findall(museo(cienciasNaturales), puntoDeInteres(museo(cienciasNaturales), Ciudad), Museos).

ciudadInteresante(Ciudad) :-
	antigua(Ciudad),
	baresCopados(Ciudad, Bares),
	museosCopados(Ciudad, Museos),
	length(Bares, CantidadBares),
	length(Museos, CantidadMuseos),
	CantidadLugaresCopados is CantidadBares + CantidadMuseos,
	CantidadLugaresCopados > 10.
```

Podemos mejorar CiudadInteresante, ya que sumamos de forma individual museos y bares. Para eso lo trabajamos de forma polimorfica (que respondan al mismo predicado)

```prolog
ciudadInteresante(Ciudad) :-
	antigua(Ciudad),
	cosasCopadas(Ciudad, Cosas),
	length(Cosas, CantidadCosas),
	CantidadCosas > 10.

cosasCopadas(Ciudad, Cosas) :-
  findall(Cosa, (puntoDeInteres(Cosa, Ciudad), copada(Cosa)), Cosas).

copada(museo(cienciasNaturales)).
copada(bar(VariedadesCerveza)):-VariedadesCerveza > 4.
```

## Inversibilidad

“Un viejo maestro es aquel pensador en el que todos sus pensamientos llegan a nuestros días”.

```prolog
viejoMaestro(Pensador) :-
	forall(pensamiento(Pensador, Pensamiento),
       llegaANuestrosDias(Pensamiento)).
```

Esta ok pero 

 solo tiene un detalle: no es inversible. Recordemos que para que un predicado sea inversible tengo que ligar las variables, entonces utilizo un predicado generador:

```prolog
viejoMaestro(Pensador) :- 
pensador(Pensador),
forall(pensamiento(Pensador, Pensamiento),
       llegaANuestrosDias(Pensamiento)).
```

En todo caso el problema no es conceptual, sino una restricción que impone el motor de inferencia Prolog. Esta solución no calza en sí como un bad smell, o al menos está en una categoría diferente a las anteriores.

## Agregan el resto de code smells que faltan opcional