# TEMAS
Predicados de orden superior.


# NOT/1


Hasta el momento hemos definido predicados que trabajan con individuos simples o compuestos:

```prolog
? humano(socrates).
? par(2).
? longitud([1, 2, 3], 3).
? nacio(melina, fecha(19, 8, 2001)).
```

Ahora tenemos la siguiente base de conocimientos de apostadores de ruleta, donde relacionamos los números que juega cada apostador:

```prolog
juega(julia, 3).
juega(beto, 6).
juega(dodain, 5).
juega(juana, 15).
juega(sergio, 3).
```

Decimos que un numero es yeta si nadie apuesta por el

```prolog
yeta(Numero):-not(juega(_, Numero)).
```

¿Qué aridad tiene el predicado not? → 1
Pero el argumento que recibe... es un predicado.
Entonces es un predicado de orden superior.


## Consultas e inversibilidad

```prolog
?- yeta(3).
false.


?- yeta(25).
true.
```

¿Qué pasa cuando intentamos una consulta existencial?

```prolog
?- yeta(Numero).
false.
```

La consulta no puede satisfacerse.

```prolog
yeta(Numero):-not(juega(_, Numero)).
```

Nosotros definimos en la base de conocimientos qué números juega la gente, pero no le decimos a Prolog cuál es el universo de números que podemos apostar a la ruleta. Y el motor de inferencia de Prolog solo está preparado para encontrar cuáles son todos los individuos que satisfacen una relación, no los que no la satisfacen.


Si queremos que el predicado sea inversible, debemos ligar todas las variables del o de los predicados involucrados en el not/1. En nuestro caso solo tenemos que hacerle saber al motor el universo de números de la ruleta.


Los números posibles son del 1 al 36. Para eso nos valemos de un predicado que relaciona dos números con un tercero que se encuentra en el intervalo cerrado entre ellos.

```prolog
numeroRuleta(Numero):- between(1, 36, Numero).
yeta(Numero):-numeroRuleta(Numero), not(juega(_, Numero)).
```

numeroRuleta/1 es un predicado inversible, esto significa que admite tanto consultas individuales (sí/no) como consultas existenciales:
Y de esa manera también podemos admitir consultas existenciales sobre los números yeta, porque numero/1 funciona como predicado generador del universo de números que se pueden apostar a la ruleta:


## Repaso de inversibilidad


recordemos que todo lo que no está en la base de conocimientos no existe.
Tengo un grupo de perros famosos: Lassie, RIn tin tin, Benji, Beethoven


Entonces, ¿cómo sé cuáles son los perros que no son famosos si no conozco los perros que forman parte de mi universo?  No puedo pedirle al motor que resuelva:

```prolog
perroComun(Perro):-not(perroFamoso(Perro)).  
```

Por eso el predicado perroComun no es inversible. ¡Sólo sabe los perros famosos, no los comunes!


### Soluciones


1. Usar un predicado generador que instancie todos los perros que existan.

```prolog
perroComun(Perro):-perro(Perro), not(perroFamoso(Perro)).
```

O sea, si tengo el universo de perros y el universo de perros famosos, puedo determinar si un perro es común o famoso.


2. Agregar el complemento de los perros famosos definiendo perroComun como un hecho. De esa manera transformo un predicado negativo en uno asertivo:

```prolog
perroComun(bachi).
perroComun(sultan).
perroComun(copito).
```

En ambos casos la dificultad es que no siempre conozco el conjunto universal.


# FORALL/2


Queremos verificar que una condición se cumpla para todas las variables posibles. Tenemos esta base de conocimientos:

```prolog
materia(algoritmos, 1).
materia(analisisI, 1).
materia(pdp, 2).
materia(proba, 2).
materia(sintaxis, 2).


nota(nicolas, pdp, 10).
nota(nicolas, proba, 7).
nota(nicolas, sintaxis, 8).
nota(malena, pdp, 6).
nota(malena, proba, 2).
nota(raul, pdp, 9).
```

**“Un alumno terminó un año si aprobó todas las materias de ese año”**

```prolog
terminoAnio(Alumno, Anio):-
   forall(materia(Materia, Anio), aprobo(Alumno, Materia)).


aprobo(Alumno, Materia):-nota(Alumno, Materia, Nota), Nota >= 6.
```

## Inversibiilidad

```prolog
?- terminoAnio(Alumno, 2).
```

no es inversible, porque esto implica que al tratar de unificar los individuos que cumplen la consulta, el predicado forall queda unificado así:

```prolog
... :- forall(materia(Materia, 2), aprobo(Alumno, Materia))
```

Las incógnitas son Alumno y Materia, entonces forall se satisfará si todos los alumnos ha terminado segundo año
Qué puedo hacer para que el forall haga la pregunta por cada alumno? El alumno no debe ser incógnita al momento de usar el forall:

```prolog
terminoAnio(Alumno, Anio):-
     alumno(Alumno),
     forall(materia(Materia, Anio), aprobo(Alumno, Materia)).
```
No hace falta denifinir todos los alumnos uno por uno,  alcanza con basarme en el predicado nota/1

```prolog
alumno(Alumno):-nota(Alumno, _ , _).
```

Enotncesahora si puedo preguntar QUE alumnos terminaron 2do año


**¿Puedo hacer la consulta termino(Alumno, Anio)?**


como está armado el predicado va a preguntar si algún alumno que encontré aprobó todas las materias de todos los años, o sea si se recibió.

```prolog
:- alumno(Alumno),
      forall(materia(Materia, Anio), aprobo(Alumno, Materia))
```

¿Qué puedo hacer para que forall pregunte si un alumno aprobó todas las materias de un año? Nos aseguramos que tanto el alumno como el año estén unificados antes de relacionarlos con el predicado forall. Instanciamos la variable anio basicamente antes de entrar al forall

```prolog
terminoAnio(Alumno, Anio):-
    alumno(Alumno),
    anio(Anio),
    forall(materia(Materia, Anio), aprobo(Alumno, Materia)).
```

Lo que estamos haciendo es fijar un dominio para los argumentos: el primer argumento no es cualquier individuo, tiene que ser un Alumno, el segundo tiene que ser un año de la carrera (no cualquier número).  Dentro de las reglas del negocio, Materia sí debe ser una incógnita, ya que si lo ligamos antes del forall estaremos preguntando si un alumno de un año aprobó una materia (que no es lo que nos piden).


## EJemplo para el Forall


En este caso debemos resolver si un auto le viene perfecto a una persona, donde le viene perfecto = tiene todas las características que la persona quiere.

```prolog
vieneCon(p206, abs).
vieneCon(p206, levantavidrios).
vieneCon(p206, direccionAsistida).
vieneCon(kadisco, abs).
vieneCon(kadisco, mp3).
vieneCon(kadisco, tacometro).


quiere(carlos, abs).
quiere(carlos, mp3).
quiere(roque, abs).
quiere(roque, direccionAsistida).


leVienePerfecto(Auto, Persona):-
    forall(quiere(Persona, Caracteristica),
           vieneCon(Auto, Caracteristica)).
```
Esta regla no es inversible en ninguno de los dos argumentos porque el forall necesita que tanto Persona como Auto vengan ligadas.
Quiero que para cada par (Auto, Persona) relacione si un auto concreto tiene todo lo que una persona concreta quiere.
Por eso tengo que generar tanto los autos como las personas, y eso se hace así:

```prolog
auto(p206).
auto(kadisco).
persona(carlos).
persona(roque).


leVienePerfecto(Auto, Persona):- auto(Auto), persona(Persona),
    forall(quiere(Persona, Chiche), vieneCon(Auto, Chiche)).
```

**REPASO**
- ciertos predicados escritos en forma natural no son inversibles por distintos motivos: gracias al concepto de generación zafamos de esa limitación mediante la técnica de resolver las variables que están sin ligar


- a qué se debe la limitación: a que hay un motor imperfecto porque no es computacionalmente posible tener todos los hechos en la base de conocimiento


# Logica de conjuntos


Un conjunto A está incluido en otro B si todos los elementos de A están en B.

```prolog
incluido(A, B):-forall(member(X, A), member(X, B)).
```

Un conjunto A es disjunto de B si se cumple que todos los elementos de A no están en B.

```prolog
disjuntos(A, B):-forall(member(X, A), not(member(X, B))).
```

# Del NOT al FORALL

Basicamente dice como dicen lo mismo pero de formas diferentes

# Findall















